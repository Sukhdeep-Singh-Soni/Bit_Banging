/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "bit_banging.h"


int main(void)
{
	/* GPIO configuration */
	cRccConfig();
	cGpioInit();

	uint8_t status;
#if 1
	//write sequence
	cGenerateStartCondition();
	if (!cSendDevAddress(DATA_WR)) {
		if (!cWriteRegAddress(0x0000)) {
			if (!cSendData(0x28U)) {
				status = 0;//data sent
				cGenerateStopCondition();
			} else {
				status = 1;//data not sent
				cGenerateStopCondition();
			}
		} else {
			status = 1;
			cGenerateStopCondition();
		}
	} else {
		status = 1;
		cGenerateStopCondition();
	}
	(void)status;
#endif

	//delay b/e a write and a read
	for(int i = 0; i < 50000; i++);

	//read sequence
	uint8_t u8ReadVal = 0;
	cGenerateStartCondition();
	if (!cSendDevAddress(DATA_WR)) {
		if (!cWriteRegAddress(0x0000)) {
			cGenerateStartCondition();
			if (!cSendDevAddress(DATA_RD)) {
				u8ReadVal = cReadData(&u8ReadVal);
				cGenerateStopCondition();
			} else {
				status = 1;
				cGenerateStopCondition();
			}
		} else {
			status = 1;
			cGenerateStopCondition();
		}
	} else {
		status = 1;
		cGenerateStopCondition();
	}
	(void)status;
	(void)u8ReadVal;

    /* Loop forever */
	for(;;) {
		//cGpioTogglePin(GPIOA_BASEADDR, GPIO_PIN5);
		//cDelay();
	}
}



void cGpioInit(void) {
	// Pin assignment
	//PA5 - GPIO led on board
	//PA2 - SCL
	//PA3 - SDA

//	uint32_t *pGpioAModer = (uint32_t*)(GPIOA_BASEADDR + GPIO_MODER_OFFSET);
//	*pGpioAModer |= (0x1 << (2 * GPIO_PIN5));

	//SCL output configuration
	*((uint32_t*)(GPIOA_BASEADDR + GPIO_OPTYPE_OFFSET)) |= (0x1U << (SCL_PIN));		//open drain configuration
	*((uint32_t*)(GPIOA_BASEADDR + GPIO_MODER_OFFSET)) |= (0x1U << (2 * SCL_PIN));	//MODER - output mode

	//SDA output configuration
	*((uint32_t*)(GPIOA_BASEADDR + GPIO_OPTYPE_OFFSET)) |= (0x1U << (SDA_PIN));		//open drain configuration
	*((uint32_t*)(GPIOA_BASEADDR + GPIO_MODER_OFFSET)) |= (0x1U << (2 * SDA_PIN));	//MODER - output mode
}

void cGpioTogglePin(uint32_t u32GpioBaseAddr, uint8_t u8PinNumber) {
	*((uint32_t*)(u32GpioBaseAddr + GPIO_ODR_OFFSET)) ^= (0x01U << u8PinNumber);
}

void cRccConfig(void) {
	uint32_t* pAhb1Enr = (uint32_t*)(RCC_BASEADDR + RCC_AHB1ENR_OFFSET);
	*pAhb1Enr |= (1 << 0);	//enable clock for GPIOA peripheral in AHB1ENR
}

void cDelay(void) {
	for (int i = 0; i < 500000; i++)
			;
}

//end
